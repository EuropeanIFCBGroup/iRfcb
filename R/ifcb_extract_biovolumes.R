utils::globalVariables("biovolume")
#' Extract Biovolumes from IFCB Data and Compute Carbon Content
#'
#' This function reads biovolume data from feature files generated by the `ifcb-analysis` repository (Sosik and Olson 2007)
#' and matches them with corresponding classification results or manual annotations. It calculates biovolume in cubic micrometer and
#' determines if each class is a diatom based World Register of Marine Species (WoRMS). Carbon content
#' is computed for each roi using specific conversion functions depending on whether the class
#' is identified as a diatom or not, according to Menden-Deuer and Lessard 2000.
#'
#' @param feature_files A path to a folder containing feature files or a character vector of file paths.
#' @param mat_folder Path to the folder containing class or manual files.
#' @param class2use_file A character string specifying the path to the file containing the class2use variable (default NULL).
#' @param micron_factor Conversion factor for biovolume to cubic microns. Default is 1 / 3.4.
#' @param diatom_class A string vector of diatom class names in the World Register of Marine Species (WoRMS). Default is "Bacillariophyceae".
#' @param threshold Threshold for selecting class information ("opt" or other, default is "opt").
#' @param multiblob A logical indicating whether to include multiblob features. Default is FALSE.
#' @param feature_recursive Logical. If TRUE, the function will search for feature files recursively within the `feature_folder`. Default is TRUE.
#' @param mat_recursive Logical. If TRUE, the function will search for MATLAB files recursively within the `mat_folder`. Default is TRUE.
#' @param feature_folder
#'     `r lifecycle::badge("deprecated")`
#'     Use \code{feature_files} instead.
#' @param class_folder
#'     `r lifecycle::badge("deprecated")`
#'     Use \code{mat_folder} instead.
#'
#' @return A data frame containing 'sample', 'classifier' 'roi_number', 'class', 'biovolume_um3', and computed 'carbon_pg'.
#'
#' @details
#' The function combines biovolume data extracted from feature files with class
#' information read from corresponding MATLAB files. It determines if each class is a
#' diatom based on user-defined criteria and computes carbon content using conversion
#' functions specific to diatoms and non-diatom protists.
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' feature_files <- "data/features"
#' mat_folder <- "data/classified"
#' biovolume_df <- ifcb_extract_biovolumes(feature_files, mat_folder)
#' print(biovolume_df)
#' }
#'
#' @references Menden-Deuer Susanne, Lessard Evelyn J., (2000), Carbon to volume relationships for dinoflagellates, diatoms, and other protist plankton, Limnology and Oceanography, 3, doi: 10.4319/lo.2000.45.3.0569.
#' @references Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
#'
#' @importFrom R.matlab readMat
#' @importFrom dplyr left_join mutate case_when select
#' @importFrom stringr str_replace
#' @importFrom lifecycle is_present deprecate_warn deprecated
#'
#' @export
#'
#' @seealso \code{\link{ifcb_read_features}} \code{\link{ifcb_is_diatom}} \url{https://www.marinespecies.org/}
ifcb_extract_biovolumes <- function(feature_files, mat_folder, class2use_file = NULL,
                                    micron_factor = 1 / 3.4, diatom_class = "Bacillariophyceae",
                                    threshold = "opt", multiblob = FALSE,
                                    feature_recursive = TRUE, mat_recursive = TRUE,
                                    feature_folder = deprecated(), class_folder = deprecated()) {

  # Warn the user if feature_folder is used
  if (lifecycle::is_present(feature_folder)) {

    # Signal the deprecation to the user
    deprecate_warn("0.3.4", "iRfcb::ifcb_extract_biovolumes(feature_folder = )", "iRfcb::ifcb_extract_biovolumes(feature_files = )")

    # Deal with the deprecated argument for compatibility
    feature_files <- feature_folder
  }

  # Warn the user if class_folder is used
  if (lifecycle::is_present(class_folder)) {

    # Signal the deprecation to the user
    deprecate_warn("0.3.4", "iRfcb::ifcb_extract_biovolumes(class_folder = )", "iRfcb::ifcb_extract_biovolumes(mat_folder = )")

    # Deal with the deprecated argument for compatibility
    mat_folder <- class_folder
  }

  # Check if feature_files is a single folder path or a vector of file paths
  if (length(feature_files) == 1 && file.info(feature_files)$isdir) {
    feature_files <- list.files(feature_files, pattern = "D.*\\.csv", full.names = TRUE, recursive = feature_recursive)
  }

  # List mat files
  mat_files <- list.files(mat_folder, pattern = "D.*\\.mat", full.names = TRUE, recursive = mat_recursive)

  if (length(mat_files) == 0) {
    stop("No class data files found")
  }

  # Check if files are manually classified
  is_manual <- "class2use.manual" %in% ifcb_get_mat_names(mat_files[1])

  if (is_manual && is.null(class2use_file)) {
    stop("class2use must be specified when extracting manual biovolume data")
  }

  # Extract date-time from class file paths
  class_date_times <- gsub(".*D(\\d{8}T\\d{6})_.*", "\\1", mat_files)

  # Extract date-time from feature file paths
  extracted_dates <- sub(".*D(\\d{8}T\\d{6}).*", "\\1", feature_files)

  # List matching feature files
  feature_files <- feature_files[extracted_dates %in% class_date_times]

  # Read feature files
  features <- ifcb_read_features(feature_files, multiblob = multiblob)

  if (length(features) == 0) {
    stop("No feature data files found")
  }

  # Initialize an empty list to store data frames
  data_list <- list()

  # Loop through each feature file
  for (file_name in names(features)) {
    file_data <- features[[file_name]]

    # Create a data frame with sample, roi_number, and biovolume
    temp_df <- data.frame(
      sample = ifelse(multiblob, str_replace(file_name, "_multiblob_v\\d+.csv", ""), str_replace(file_name, "_fea_v\\d+.csv", "")),
      roi_number = file_data$roi_number,
      biovolume = file_data$Biovolume
    )

    # Append to the list
    data_list <- append(data_list, list(temp_df))
  }

  # Combine all data frames into one
  biovolume_df <- do.call(rbind, data_list)

  # Find unique samples in biovolume_df
  unique_samples <- unique(biovolume_df$sample)

  # Function to check if any sample name is in the class path
  contains_sample <- function(class_path, samples) {
    # Check if any of the samples are present in the class_path
    any(sapply(samples, function(sample) grepl(sample, class_path)))
  }

  # Filter classes where the sample name exists in biovolume_df$sample
  matching_mat <- mat_files[sapply(mat_files, contains_sample, samples = unique_samples)]

  # Initialize an empty list to store data frames
  tb_list <- list()

  # Initialize a list to store all warnings
  warning_list <- list()

  if (is_manual) {

    class_df <- ifcb_count_mat_annotations(matching_mat,
                                           class2use_file,
                                           sum_level = "roi")

    names(class_df)[2] <- "roi_number"

    class_df$classifier <- NA

  } else {
    # Loop through matching classes
    for (class in seq_along(matching_mat)) {
      # Capture warnings for each readMat call
      temp <- suppressWarnings({
        temp_result <- readMat(matching_mat[class])
        warning_list <- c(warning_list, warnings())
        temp_result
      })

      # Create a data frame with sample, roi_number, and class information
      temp_df <- data.frame(
        sample = str_replace(basename(matching_mat[class]), "_class_v\\d+.mat", ""),
        classifier = temp$classifierName,
        roi_number = temp$roinum,
        class = if (threshold == "opt") {
          unlist(temp$TBclass.above.threshold)
        } else {
          unlist(temp$TBclass)
        }
      )

      # Append to the list
      tb_list <- append(tb_list, list(temp_df))
    }
  }

  # Display the number of warnings
  num_warnings <- length(warning_list)

  if (num_warnings > 0) {
    message(sprintf("There were %d warnings (use warnings() to see them)", num_warnings))
  }

  if (!is_manual) {
    # Combine all data frames into one
    class_df <- do.call(rbind, tb_list)
  }

  # Join biovolume_df with class_df
  biovolume_df <- left_join(biovolume_df, class_df, by = c("sample", "roi_number"))

  # Calculate biovolume in cubic microns
  biovolume_df$biovolume_um3 <- biovolume_df$biovolume * (micron_factor ^ 3)

  # Determine if each class is a diatom
  unique_classes <- unique(biovolume_df$class)
  is_diatom <- data.frame(class = unique_classes, is_diatom = ifcb_is_diatom(unique_classes, diatom_class = diatom_class))
  biovolume_df <- left_join(biovolume_df, is_diatom, by = "class")

  # Filter rows where is_diatom$is_diatom is NA
  na_classes <- is_diatom[is.na(is_diatom$is_diatom), "class"]

  # Filter rows where is_diatom$is_diatom is NA
  non_diatoms <- is_diatom[!is_diatom$is_diatom, "class"]

  # Print the classes with NA values
  if (length(na_classes) > 0) {
    cat("INFO: Some classes could not be found in WoRMS. They will be assumed as NOT diatoms for carbon calculations:\n")
    cat(sort(na_classes), sep = "\n")
  }

  # Print the classes that are non-Diatoms
  if (length(non_diatoms) > 0) {
    cat("INFO: The following classes are considered NOT diatoms for carbon calculations:\n")
    cat(sort(non_diatoms), sep = "\n")
  }

  # Calculate carbon content based on diatom classification
  biovolume_df <- biovolume_df %>%
    mutate(carbon_pg = case_when(
      !is.na(is_diatom) & is_diatom ~ vol2C_lgdiatom(biovolume_um3),
      !is.na(is_diatom) & !is_diatom ~ vol2C_nondiatom(biovolume_um3),
      is.na(is_diatom) ~ vol2C_nondiatom(biovolume_um3),
      TRUE ~ NA_real_
    )) %>%
    select(-biovolume, -is_diatom)

  return(biovolume_df)
}
